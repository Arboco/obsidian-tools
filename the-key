#! /usr/bin/env fish

function get_priority
    switch $argv[1]
        case S
            echo 1
        case A
            echo 2
        case B
            echo 3
        case C
            echo 4
        case D
            echo 5
        case E
            echo 6
        case F
            echo 7
    end
end

function help_function
    echo "  -s       Respects Sequence"
    echo "  -e       Edit Sequence"
    echo "  -r       Reverses List"
    echo "  -k       Activates keyring feature"
    echo "  -a       Activates agenda"
    echo "  -c       Selects cleared and sorts in order of biggest number"
    echo "  -f       Selects favorites and sorts in order of biggest number"
    echo "  -v       Activate video functionality"
    echo "  -q       Quickly query your key contents"
    echo "  -m       Activates Mind Palace mode"
    echo "  -p       Like keyring but for Mind Palaces"
end

function true_multiline_block_ripgrep
    set temp_rg (mktemp)
    set card_type $argv[1]
    set key_string $argv[2]
    set only_key_header $argv[3]
    rg -U -oP --no-filename "$card_type:.*(?:\n(?!\s*\n).*)*?$key_string.*\$" $obsidian_folder/$notes >$temp_rg

    cat $temp_rg | while read line
        if echo $line | rg -q "($card_type:|$key_string)"
        else
            sed -i 1d $temp_rg
            continue
        end
        set puzzle_pieces $puzzle_pieces $line
        if not test -z $puzzle_pieces[2]
            if string match -q true $only_key_header
                set completed_puzzle "$puzzle_pieces[1]"
            else
                set completed_puzzle "$puzzle_pieces[2] | $puzzle_pieces[1]"
            end
            set -e puzzle_pieces
            echo $completed_puzzle
        end
    end

    rm $temp_rg
end

argparse --name=pool r/reverse s/sequence e/edit k/keyring a/agenda c/cleared f/favorite v/video q/query m/mind p/palace h/help 'n/name=' -- $argv
or return

set script_dir (realpath (status dirname))
set obsidian_folder (ot_config_grab "ObsidianMainFolder")
set obsidian_resource (ot_config_grab "ObsidianResourceFolder")
set notes (ot_config_grab "NotesFolder")
set default_pool_array (rg -l "^(I|Q|W|T):" $obsidian_folder/$notes)

if not set -q _flag_k; or not set -q _flag_p
    set key_array (rg --no-filename --no-line-number "^K:" $obsidian_folder/$notes)
end

if set -q _flag_h
    help_function
    exit
end

if set -q _flag_m
    set mindpalace_format true
end

set generate_thumbnail true
if set -q _flag_v
    set generate_thumbnail false
end

if set -q _flag_k
    rm /tmp/keyring_awk_result
    set key_array_filelist (rg -l "^K:" $obsidian_folder/$notes)
    set keyring_select (rg "^keyring:" $key_array_filelist | rg -o "#.*\b" | sort -u | string trim -lr | fzf -1 --query "$argv[1]" --delimiter='#' --with-nth=-1)
    set -e argv[1]
    set argv[1] $argv[2]
    set keyring_file_list (rg -l "keyring: $keyring_select" $key_array_filelist)
    for i in $keyring_file_list
        awk -v term="$keyring_select" 'BEGIN { RS=""; FS="\n" } $0 ~ term { print $0 "\n" }' $i >>/tmp/keyring_awk_result
    end
    set key_array (rg --no-filename --no-line-number "^K:" /tmp/keyring_awk_result)
end

if set -q _flag_p
    rm /tmp/keyring_awk_result
    set key_array_filelist (rg -l "^K:" $obsidian_folder/$notes)
    set keyring_select (rg "^mp:" $key_array_filelist | rg -oP '(?<=mp: \[\[)[^\]]*' | sort -u | string trim -lr | fzf --no-sort --style=full --preview "$script_dir/scripts/media-fzf.fish {} mp")
    set keyring_file_list (rg -l "mp: \[\[$keyring_select\]\]" $key_array_filelist)
    for i in $keyring_file_list
        awk -v term="$keyring_select" 'BEGIN { RS=""; FS="\n" } $0 ~ term { print $0 "\n" }' $i >>/tmp/keyring_awk_result
    end
    set key_array (rg --no-filename --no-line-number "^K:" /tmp/keyring_awk_result)
end

set sorted_key_array (
for line in $key_array
    # extract timestamp using regex
    set ts (string match -r '\d{4}-\d{2}-\d{2} \d{2}:\d{2}:\d{2}' -- $line)
    if test -z "$ts"
        set ts "0000-00-00 00:00:00" # fallback if no timestamp
    end
    printf "%s\t%s\n" "$ts" "$line"
end | sort | cut -f2-)

if set -q _flag_c
    set c_temp (mktemp)
    true_multiline_block_ripgrep K "cards_cleared:" >$c_temp
    #perl $script_dir/perl/add_to_key.pl "cards_cleared:" $obsidian_folder/$notes >$c_temp
    set sorted_key_array (cat $c_temp | awk '{for(i=1;i<=NF;i++){if($i ~ /^cards_cleared:/){print $(i+1) " " $0}}}' | sort -nr | cut -d' ' -f2-)
    rm $c_temp
end

if set -q _flag_f
    set c_temp (mktemp)
    true_multiline_block_ripgrep K "key_favorite:" >$c_temp
    #perl $script_dir/perl/add_to_key.pl "key_favorite:" $obsidian_folder/$notes >$c_temp
    set sorted_key_array (cat $c_temp | awk '{for(i=1;i<=NF;i++){if($i ~ /^key_favorite:/){print $(i+1) " " $0}}}' | sort -nr | cut -d' ' -f2-)
    rm $c_temp
end

if set -q _flag_r
    set sorted_key_array (printf "%s\n" $sorted_key_array | tac)
end

if set -q _flag_a
    set key_array_filelist (rg -l "^K:" $obsidian_folder/$notes)
    set agenda_keys (true_multiline_block_ripgrep K "agenda:")

    set date_list (mktemp)
    for i in $agenda_keys
        set split_key (echo $i | string split "|")
        set priority (echo $split_key[1] | rg -o "(S|A|B|C|D|E|F)")
        if echo $i | rg -q "(S|A|B|C|D|E|F) ....-..-.."
            set agenda_date (echo $split_key[1] | rg -o "(S|A|B|C|D|E|F) ....-..-.." | rg -o "....-..-..")
            echo "$agenda_date" >>$date_list
        end
        set key_header (echo $split_key[2] | string trim -lr)

        if test -z $agenda_date
            set agenda_plus_key_header "[$priority] | $key_header"
        else
            set agenda_plus_key_header "[$priority] - [$agenda_date] | $key_header"
        end
        set agenda_plus_key_header_array $agenda_plus_key_header_array $agenda_plus_key_header
        set -e agenda_date
    end

    set today (date +%s)
    set closest_date ""
    set min_diff ""

    for line in (cat $date_list)
        set timestamp (begin; date -d $line +%s 2>/dev/null; end)

        if test -z "$timestamp"
            continue
        end

        set diff (math "abs($timestamp - $today)")

        if test -z "$min_diff" -o $diff -lt $min_diff
            set min_diff $diff
            set closest_date $line
        end
    end

    echo $closest_date
    rm $date_list

    set tmpfile (mktemp)

    for item in $agenda_plus_key_header_array
        set letter (string match -r '\[(.)\]' -- $item | string sub -s 2 -l 1 | string trim -lr)
        set date_str (string match -r '\[(\d{4}-\d{2}-\d{2})\]' -- $item | string trim -c '[]' | sort -u)
        set date_epoch (date -d $date_str +%s 2>/dev/null)
        set delta (math "abs($date_epoch - $today)")
        printf "%02d\t%09d\t%s\n" (get_priority $letter) $delta "$item" >>$tmpfile
    end

    set final_sorted_agenda (sort -n $tmpfile | cut -f3-)
    rm $tmpfile
end

for i in $sorted_key_array
    set trim_sorted_key_array $trim_sorted_key_array (echo $i | string split "`")[1]
end

if set -q _flag_a
    set select_key (for i in $final_sorted_agenda; echo $i; end | sed "s/\] - \[$closest_date/\] ⏰\[$closest_date/g" | fzf --no-sort --style=full --preview "$script_dir/scripts/the-key-fzf.fish {}")
else
    set select_key (for i in $trim_sorted_key_array; echo $i; end | fzf -1 --no-sort --delimiter='K: ' --with-nth=-1 --style=full --query "$argv[1]" --preview "$script_dir/scripts/the-key-fzf.fish {}")
end
if echo $select_key | rg "^\[.\]"; or echo $select_key | rg "^key"; or echo $select_key | rg "^cards_cleared"
    set select_key (echo $select_key | string split " | ")[2]
end
set select_key_trim (echo $select_key | string trim -lr)
if string match -q "K:" $select_key_trim
    echo "Key is empty, exiting out of safety"
    exit
end

set key_md (rg -l $select_key $obsidian_folder/$notes)
set tmp_key_contents /tmp/the-key-content

awk -v search="$select_key_trim" '
      index($0, search) {flag=1}
      flag {print}
      /^$/ && flag {flag=0}
                              ' $key_md >$tmp_key_contents

set num 1
while true
    if rg "^string$num:" $tmp_key_contents
        set string (rg "^string$num:" $tmp_key_contents | rg -oP "(?<=string$num: ).*" | string trim -lr)
        set filtered_pool $filtered_pool (rg -lF "$string" $default_pool_array)
        set num (math $num + 1)
    else
        break
    end
end

set num 1
while true
    if rg "^regex$num:" $tmp_key_contents
        set regex (rg "^regex$num:" $tmp_key_contents | rg -oP "(?<=regex$num: ).*" | sed 's/"//g' | string trim -lr)
        set filtered_pool $filtered_pool (rg -lP $regex $default_pool_array)
        set num (math $num + 1)
    else
        break
    end
end

if rg "^links:" $tmp_key_contents
    set md_links (rg "^links:" $tmp_key_contents | rg -o "\[.*\]" | string split "] [" | sed 's/\[//g' | sed 's/\]//g' | string trim -lr)
    set filtered_pool $filtered_pool (for i in $md_links; find $obsidian_folder/$notes/* -type f -name "$i.md"; end)
end

if rg "^tags:" $tmp_key_contents
    set tag_list (rg "^tags:" $tmp_key_contents | rg -o "#.*\b" | sed 's/#//g' | string split " " | string trim -lr)
    for i in $tag_list
        set filtered_pool $filtered_pool (rg -l "^  - $i\$" $default_pool_array)
    end
end

if rg "^c-tags:" $tmp_key_contents
    set ctag_list (rg "^c-tags:" $tmp_key_contents | rg -o "#.*\b" | sed 's/#//g' | string split " " | string trim -lr)
    set cpool_one (rg -l "^  - $ctag_list[1]\$" $default_pool_array)
    set cpool_two (rg -l "^  - $ctag_list[2]\$" $cpool_one)
    if test -z ctag_list[3]
        set cpool_three (rg -l "^  - $ctag_list[2]\$" $cpool_two)
        set filtered_pool $filtered_pool $cpool_three
    else
        set filtered_pool $filtered_pool $cpool_two
    end
end

if rg "^family:" $tmp_key_contents
    if rg "^family:.*parent" $tmp_key_contents
        set parent_name (rg -oP "(?<=parent: \"\[\[)[^\]]*" $key_md)
        set parent_file (find $obsidian_folder/$notes/* -type f -iname "$parent_name.md")
        set filtered_pool $filtered_pool $parent_file
    end

    if rg "^family:.*siblings" $tmp_key_contents
        set parent_name (rg -oP "(?<=parent: \"\[\[)[^\]]*" $key_md)
        set parent_file (find $obsidian_folder/$notes/* -type f -iname "$parent_name.md")
        set child_names (awk '/^child:/ {flag=1; next} flag && /^  - / {print $0} flag && !/^  - / {flag=0}' $parent_file | sed 's/[][]//g; s/"//g; s/-//g; s/^[[:space:]]*//; s/[[:space:]]*$//')
        for i in $child_names
            set child_file (find $obsidian_folder/$notes/* -type f -iname "$i.md")
            set filtered_pool $filtered_pool $child_file
        end
        set filtered_pool (for i in $filtered_pool; echo $i; end | sort -u)
    end

    if rg "^family:.*children" $tmp_key_contents
        set child_names (awk '/^child:/ {flag=1; next} flag && /^  - / {print $0} flag && !/^  - / {flag=0}' $key_md | sed 's/[][]//g; s/"//g; s/-//g; s/^[[:space:]]*//; s/[[:space:]]*$//')
        for i in $child_names
            set child_file (find $obsidian_folder/$notes/* -type f -iname "$i.md")
            set filtered_pool $filtered_pool $child_file
        end
        set filtered_pool (for i in $filtered_pool; echo $i; end | sort -u)
    end
end

if rg "^f-links:" $tmp_key_contents
    set md_links (rg "^f-links:" $tmp_key_contents | rg -o "\[.*\]" | string split "] [" | sed 's/\[//g' | sed 's/\]//g' | string trim -lr)
    set link_evil_pool (for i in $md_links; find $obsidian_folder/$notes/* -type f -name "$i.md"; end)
    for i in $filtered_pool
        if string match $i (for e in $link_evil_pool; echo $e; end)
        else
            set link_survivor_pool $link_survivor_pool $i
        end
    end
    set filtered_pool $link_survivor_pool
end

if rg "^f-tags:" $tmp_key_contents
    set ftag_list (rg "^f-tags:" $tmp_key_contents | rg -o "#.*\b" | sed 's/#//g' | string split " " | string trim -lr)

    set tag_evil_regex_ready (echo $ftag_list | sed 's/ /|/g')
    for i in $filtered_pool
        if rg -qP "^  - ($tag_evil_regex_ready)" "$i"
        else
            set tag_survivor_pool $tag_survivor_pool $i
        end
    end
    set filtered_pool $tag_survivor_pool
end

set fnum 1
while true
    if rg "^f-string$fnum:" $tmp_key_contents
        set string (rg "^f-string$fnum:" $tmp_key_contents | rg -oP "(?<=f-string$fnum: ).*" | string trim -lr)
        set filtered_pool (rg -lF --files-without-match "$string" $filtered_pool)
        set fnum (math $fnum + 1)
    else
        break
    end
end

if test -z $filtered_pool[1]
else
    set question_array (rg --no-filename --no-line-number "^(I|Q|W|T):" $filtered_pool)
end

if rg "^subtags:" $tmp_key_contents
    set subtag_list (rg "^subtags:" $tmp_key_contents | rg -o "#.*\b" | string split " " | string trim -lr)
    for i in $subtag_list
        set question_array $question_array (rg --no-filename --no-line-number "^(Q|I|T|W):.*$i" $default_pool_array)
    end
end

set cnum 1
while true
    if rg "^cardstring$cnum:" $tmp_key_contents
        set cardstring (rg -oP "(?<=cardstring$cnum: ).*" $tmp_key_contents | string trim -lr)
        set question_array $question_array (true_multiline_block_ripgrep "(Q|I|T|W)" "$cardstring" true $default_pool_array)
        set cnum (math $cnum + 1)
    else
        break
    end
end

if rg "^a-subtags:" $tmp_key_contents
    set a_subtag_list (rg "^a-subtags:" $tmp_key_contents | rg -o "#.*\b" | string split " " | string trim -lr)
    set a_regex_ready (echo $a_subtag_list | sed 's/ /|/g')
    for i in $question_array
        if echo $i | rg -q "^(Q|I|T|W):.*$a_regex_ready"
            set a_array_sort $a_array_sort $i
        end
    end
    set question_array $a_array_sort
end

if rg "^contains:" $tmp_key_contents
    set contains (rg -oP "(?<=contains: ).*" $tmp_key_contents | string trim -lr)
    set temp_contains (mktemp)
    true_multiline_block_ripgrep "(Q|I|T|W)" "$contains" true >$temp_contains
    set question_array (cat $temp_contains)
    rm $temp_contains
end

if rg "^f-subtags:" $tmp_key_contents
    set evil_subtag_list (rg "^f-subtags:" $tmp_key_contents | rg -o "#.*\b" | string split " " | string trim -lr)

    set subtag_evil_regex_ready (echo $evil_subtag_list | sed 's/ /|/g')
    for i in $question_array
        if echo $i | rg -q "$subtag_evil_regex_ready"
        else
            set survivor_subtag_pool $survivor_subtag_pool $i
        end
    end
    set question_array $survivor_subtag_pool
end

if rg "^remove:" $tmp_key_contents
    set remove (rg -oP "(?<=remove: ).*" $tmp_key_contents | string trim -lr)
    for i in $question_array
        set temp_remove (mktemp)
        set true_file_md (rg -lF "$i" $default_pool_array)
        perl $script_dir/perl/contains.pl "$i" "$remove" $true_file_md >$temp_remove
        if rg -q "$remove" $temp_remove
        else
            set removed_question_array $removed_question_array $i
        end
        rm $temp_remove
    end
    set question_array $removed_question_array
end

set sorted_question_array (for i in $question_array; echo $i; end | sort -u)
set question_array $sorted_question_array

set count_q (echo $question_array | rg -o "Q:" | wc -l)
set count_i (echo $question_array | rg -o "I:" | wc -l)
set count_w (echo $question_array | rg -o "W:" | wc -l)
set count_t (echo $question_array | rg -o "T:" | wc -l)
set count_c (echo $question_array | rg -o "(Q|I|W|T):" | wc -l)

if rg "^timer:" $tmp_key_contents
    set choice (rg -oP "(?<=timer: ).*" $tmp_key_contents | string trim -lr)
    set second_counter $choice
end

if rg "^skip:" $tmp_key_contents
    set choice (rg -oP "(?<=skip: ).*" $tmp_key_contents | string trim -lr)
else
    set choice (gum choose --limit 1 "Combined ($count_c)" "Question ($count_q)" "Inspiration ($count_i)" "Wiki ($count_w)" "Task ($count_t)"| string split " ")[1]
end
if string match -q Question $choice
    set selection Q
else if string match -q Inspiration $choice
    set selection I
else if string match -q Wiki $choice
    set selection W
else if string match -q Task $choice
    set selection T
else if string match -q Combined $choice
    set selection "(Q|I|W|T)"
end

# Sorting Algorithm
for i in $question_array
    if echo $i | rg -q "....-..-.. ..:..:.."
        set raw_date (echo "$i" | rg -o "....-..-.. ..:..:..")
        if echo $i | rg -Pq "(?<=S-Value: )[-0-9]*"
            set raw_value (echo $i | rg -oP "(?<=S-Value: )[-0-9]*")
        else
            set raw_value 0
        end
        set unix_timestamp (date -d "$raw_date" +%s)
        set value_seconds (ot_config_grab "ValueSeconds")
        set final_second_value (math $raw_value x $value_seconds)
        set unix_result (math $unix_timestamp + $final_second_value)
    else
        set unix_result 0
    end
    set unix_array $unix_array "$unix_result $i"
end

set sorted_unix_array (for i in $unix_array
    echo $i 
end | sort -n)

for i in $sorted_unix_array
    set final_sorted_array $final_sorted_array (echo "$i" | rg -o "(Q|I|W|T).*")
end

if set -q _flag_s

    set x (printf "%s\n" $final_sorted_array | awk '
        {
          if (match($0, /#[0-9]+(\.[0-9]+)?/)) {
              raw = substr($0, RSTART + 1, RLENGTH - 1)  # remove #
              split(raw, parts, ".")
              int_part = parts[1]
              dec_part = (length(parts) > 1) ? parts[2] : "0"
              dec_part = sprintf("%-04s", dec_part)  # pad decimals for proper sort
              sort_key = int_part "." dec_part
          } else {
              sort_key = "999999.9999"
          }
          print sort_key "\t" $0
        }
' | sort -n | cut -f2-)

    set final_sorted_array $x
end

rm /tmp/the-card_final_sorted_array
for i in $final_sorted_array
    echo $i >>/tmp/the-card_final_sorted_array
end

clear

if set -q _flag_e
    set sequence 1
    set numline 1
    while true
        set cur_line (awk -v n=$numline 'NR == n' /tmp/the-card_final_sorted_array)
        set target_md (rg -lF "$cur_line" $obsidian_folder/$notes)
        set split_key (echo $cur_line | string split "`")
        echo $cur_line
        echo ""
        echo "Sequence currently at $sequence"
        set user_input (gum input --placeholder "s - Sequence | 0 - Stop")
        if string match -q s $user_input
            if echo $cur_line | rg "....-..-.."
                if echo $cur_line | rg "#[0-9]+"
                    set new_key (echo $cur_line | string replace -r '#[0-9]+' "#$sequence")
                else
                    set new_key (echo $cur_line | string trim -lr)
                    set new_key "$new_key #$sequence"
                    set new_key "$new_key `$split_key[2]`"
                end
            else
                if echo $cur_line | rg "#[0-9]+"
                    set new_key (echo $cur_line | string replace -r '#[0-9]+' "#$sequence")
                else
                    set new_key (echo $cur_line | string trim -lr)
                    set new_key "$cur_line #$sequence"
                end
            end
            set sequence (math $sequence + 1)
            awk -v s1="$cur_line" -v s2="$new_key" '{gsub(s1, s2)}1' $target_md >tmp && mv tmp $target_md
            awk -v val="$cur_line" '$0 != val' /tmp/the-card_final_sorted_array >tmp && mv tmp /tmp/the-card_final_sorted_array
        end
        if string match -q 0 $user_input
            exit
        end
        set line_count (cat /tmp/the-card_final_sorted_array | count)
        set numline (math $numline + 1)
        if test $numline -gt $line_count
            set numline 1
        end
        if not grep -q '[^[:space:]]' /tmp/the-card_final_sorted_array
            exit
        end
        clear
    end
end

if set -q _flag_q
    cat /tmp/the-card_final_sorted_array | fzf --no-sort --style=full --query "$argv[1]" --preview "$script_dir/scripts/the-key-fzf.fish {}"
    exit
end
set the_key_activated 1
source $script_dir/scripts/the-card-output.fish
